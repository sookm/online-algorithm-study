혹시 PR이 낯선 분들을 위해...부족하지만...제가 예전에 작성한 PR입니다
자신의 풀이를 간단하게 설명과 시간복잡도를 작성하면 됩니다! 질문사항이 있다면 스터디원 같이 고민해 볼 수 있을거에요🤔

# 문제1 (문제 제목) 
숫자를 그대로 정렬하면 첫 자리수 상관없이 수의 크기대로로 처리되기 때문에 숫자를 문자로 바꿔 정렬하면 사전순처럼 되는 점을 이용하였습니다. 이를 역순으로 나열하여 가장 큰 수를 만들 수 있었습니다. 과정에서 두가지 시행착오는 블로그를 참고하여 형변환을 추가해 해결하였습니다. 
1. 처음 코드로는 결과가 3305여야 하는데 3053이 되는 식으로 3, 30이 있으면 3이 앞으로 오지 않고 30이 앞으로 왔다. `key = lambda x: x*3` 를 추가하여 '3' → '333', '30' → '303030' 으로 비교하여 원하는 순서로 정렬할 수 있었습니다. 
2. 그냥 `''.join(numbers)`를 반환하면 마지막 tc를 통과하지 못했습니다. `return str(int(''.join(numbers)))`로 수정하였더니 통과할 수 있었습니다. 
- 시간 복잡도: O(NlogN)
# 문제2 (문제 제목)
처음엔 permutations을 사용해서 가로배치를 얼마나 할 수 있는지에 따라 조합 개수를 구했습니다...하지만 엄청난 시간초과들을 보고 무엇인가 잘못되었다고 생각하였습니다... 

n이 1, 2일때 배치들이 바닥이 커져도 계속 쓰인다는 점을 봤을때 큰 문제를 작은 문제로 나눌 수 있고 작은 문제에서 구한 값이 그것을 포함하는 큰 문제에서도 동일하게 쓰일 수 있다는 DP를 사용한다고 생각했습니다. 

이후 다시 풀고 커밋한 코드에서는 
- ` dp`배열에 필요한 값을 저장하여 이를 재활용하여 풀 수 있었습니다. 
- 시간 복잡도: O(N)

**Q1** 메모이제이션과 DP가 다른건가요..?
**Q2** 처음 코드의 시간복잡도는 O((n//2+1)*n!)일까요..?